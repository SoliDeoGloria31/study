day10回顾
  函数名是变量，它用来绑定"函数"
    函数可以作为参数传入另一个函数
    函数可以返回另一个函数
  函数的嵌套定义
  def f1():
      def f2():
          pass
      f2()

四个作用域:
  局部作用域
  外部嵌套函数作用域
  全局作用域
  内建作用域
LEGB

global 语句
nonlocal 语句

lambda 表达式
  作用:
    创建简单的匿名函数
  语法:
     lambda 形参列表: 表达式
    等同于:
      def xxxx(形参列表):
          return 表达式
  
eval(字符串, globals=None, locals=None) 函数
exec(字符串, globals=None, locals=None) 函数





day11 笔记:
  
函数式编程 Functional Programming
  函数式编程是指用一系列函数解决问题

好处:
  用每一个函数完全细小的功能，一系列函数的任意组合可以完成大问题
  函数仅接受输入并产生输出，不包含任何能影响输出的内部状态


函数的可重入性
  当一个函数没有访问除局部变量以外的变量，则此函数为可重入函数

  说明:
    可重入函数输入一定．结果必然一定
  示例:
    # 可重入函数:
    def myadd1(x, y):
        return x + y
    # 不可重入函数
    s = 0
    def myadd2(x, y):
        global s
        s += x + y
        return s


高阶函数 High Order Function
什么是高阶函数:
  满足下列条件中的一个的函数即为高阶函数
    1. 函数接收一个或多个函数作为参数传入
    2. 函数返回一个函数
  
python 内置的高阶函数:
  map, filter, sorted

map 函数
  参数格式:
    map(func, iterable, ...)
  参数:
    func 对可迭代对象的数据进行处理的函数,函数的参数必须
       与可迭代对象的个数相同
    iterable, 一个或多个可迭代对象,用来给map提供数据
  返回值:
    可迭代对象
  示例见:
    map.py
    map2.py

练习:
  1. 求:
    1**2 + 2**2 + 3**2 + .... + 9**2的和
  2. 求:
    1**3 + 2**3 + 3**3 + .... + 9**3的和
  3. 求:
    1**9 + 2**8 + 3**7 + .... + 9**1的和

filter 函数
  参数格式:
    filter(func, iterable)
  参数说明:
    func 含有一个形参的数据处理函数,此函数传入的值为iterable
         中提供的数据,func将对iterable中的每个元素进行求布尔
         值,返回True则保留此数据,返回False则将此数据丢弃
    iterable 为提供数据的可迭代对象
  返回值:
    可迭代对象
  作用:
    筛选数据
  示例见:
    filter.py
练习:
  1. 用filter 生成能够提供偶数可迭代对象,生成1 ~ 20 的偶数,
     将这些偶数存于列表中,再打印这个列表(不包含20)

  2. 用filter函数,将1~100之间所有的素数prime 放入到列表中,
     再打印这个列表


sorted 函数:
  作用:
    将原可迭代对象的数据进行排序,生成排序后的列表
  格式:
    sorted(iterable, key=None, reverse=False)
  参数说明:
    iterable  用来提供数据的可迭代对象
    key       函数是用来提供一个值,这个值将作为排序的依据
    reverse   标志用来设置是否为降序排序(默认为升序排序)
  示例:
    L = [5, -2, -4, 0, 3, 1]
    L2 = sorted(L)  # [-4, -2, 0, 1, 3, 5]
    L3 = sorted(L, reverse=True)  #[5, 3, 1, 0, -2, -4]
    L4 = sorted(L, key=abs)   # L4=[0, 1, -2, 3, -4, 5]

    names = ['Tom', 'Jerry', 'Spike', 'Tyke']
    sorted(names)  # ['Jerry', 'Spike', 'Tom', 'Tyke']
    sorted(names, key=len)

练习:
  names = ['Tom', 'Jerry', 'Spike', 'Tyke']
  排序的依据为字符串的反序:
     'moT'   'yrreJ'   'skipS'     'ekyT'
  排序的结果为:
     ['Spike', 'Tyke', 'Tom', 'Jerry']
  请问如何用sorted进行排序

递归函数 recursion Function
  故事:
    从前有座山,山上有座庙,庙里有个老和尚讲故事:
      从前有座山,山上有座庙,庙里有个老和尚讲故事:
        从前有座山,山上有座庙,庙里有个老和尚讲故事:

递归函数:
  函数直接或间接的调用自身

  示例:
    # 函数直接调用自身
    def f():
        f()  # 调用自己
    f()

    # 函数间接调用自身
    def fa():
        fb()  # 调用另一个函数fb

    def fb():
        fa()  # 调用fa

    fa()
  
递归说明:
  递归一定要控制递归的层数,当符合某一条件时要终止递归调用
  几乎所有的递归都能用while循环来代替

递归的优缺点:
  优点:
    递归可以把问题简单化,让思路更为清晰,代码更为简洁
  缺点:
    递归因系统环境影响大,当递归深度太大时,可能会得到不可预知
    的结果
递归的两个阶段:
  递推阶段: 从原问题出发,按递归公式递推,从未知到已知,最终达到
       递归的终止条件
  回归阶段: 按递归终止条件求出结果,逆向逐步代入递归公式,回归
       原问题求解

递归函数的实现方法:
   先假设函数已经实现了原功能,再编写函数

示例见:
  recursion.py
# 递归求阶乘示例见:
  recursion_factorial.py

练习:
  写一个递归求和函数:
    def mysum(n):
         ...
    此函数求 1 + 2 + 3 + 4 + ..... + n 的和

    print(mysum(100))  # 5050



思考题:
  已知有五位朋友在一起
    第5个人说他比第4个人大2岁
    第4个人说他比第3个人大2岁
    第3个人说他比第2个人大2岁
    第2个人说他比第1个人大2岁
    第1个人说他10岁
  编写程序求:
    1) 算出第五个人几岁
    2) 算出第三个人几岁



闭包 closure
什么是闭包?
  闭包是指引用了此函数外部嵌套函数作用域的变量的函数

闭包必须满足三个条件:
  1. 必须有一个内嵌函数
  2. 内嵌函数必须引用外部函数中的变量
  3. 外部函数返回值必须是内嵌函数 

全局变量和局部变量的区别:
  全局变量:
    一直存在,谁都可以访问和修改
  局部变量:
    只是在函数调用时存在,只能在函数内部进行访问和修改

示例见:
  closure.py
  closure2.py
  closure3.py

闭包的注意事项:
  由于闭包会使得函数中的变量都被保存在内存中,内存消耗比较大,所
  以不能滥用闭包
闭包的应用示例见:
  closure_make_power.py


小结:
  函数式编程:
    高阶函数:
      map, filter, sorted
  
  递归函数
  闭包 


练习:
  1. 写程序算出1~20的阶乘的和,即:
    1!+2!+3!+4!+......+19!+20!
  2. 已知有列表:
    L = [[3, 5, 8], 10, [[13, 14], 15, 18], 20]
    1) 写一个函数print_list(lst) 打印出所有的数字
      如:
        print_list(L)  # 打印 3 5 8 10 13 14 ....
        (不要求打印在一行内)
    2) 写一个函数 sum_list(lst)  返回这个列表中所有数字的和
      如:
        print(sum_list(L))  # 打印 106
    注:
      type(x) 可以返回一个变量的类型
      如:
        >>> type(20) is int  # True
        >>> type([1, 2, 3]) is list  # True
  3. 修改之前学生信息的程序
    要求添加四个功能
      | 5) 按学生成绩高-低显示学生信息 |
      | 6) 按学生成绩低-高显示学生信息 |
      | 7) 按学生年龄高-低显示学生信息 |
      | 8) 按学生年龄低-高显示学生信息 |






